# C#异步

#### 为什么要使用异步
一直以来，使用远程资源的编程都是一个容易造成困惑的问题，不同于“本地资源”，远程资源的访问总会有很多意外的情况，网络环境的不稳定机器服务端的故障，会造成很多程序员完全不可控的问题，所以这也就要求程序员需要更多的去保护远程资源的调用，管理调用的取消、超市、线程的等待以及处理线程长时间没响应的情况等。而在.NET中我们通常忽略了这些挑战，事实上我们会有多种不用的模式来处理异步编程，比如在处理IO密集型操作或者高延迟的操作时候不组测线程，多数情况我们拥有同步和异步两个方法来做这件事。可是问题在于当前的这些模式非常容易引起混乱和代码错误，或者开发人员会放弃然后使用阻塞的方式去开发。

而在如今的.NET中，提供了非常接近于同步编程的编程体验，不需要开发人员再去处理只会在异步编程中出现的很多情况，异步调用将会是清晰的且不透明的，而且易于和同步的代码进行组合使用。

#### 异步的两种模型

1. I/O绑定
   
- 等待一个在 async 方法中返回 Task 或 Task<T> 的操作
  
2. CUP绑定

- 等待一个使用 Task.Run 方法在后台线程启动的操作

   

#### Task说明

Task是在线程池中开辟一个线程。线程池的线程均为[^后台线程]。

[^后台线程]:前台线程结全部束后后台线程强制关闭

Task<T> 返回值为 Task<T> 使用await返回T 或者使用result属性。

#### 执行流程

在遇到**awiat**关键字之前，程序是按照代码顺序自上而下以同步方式执行的。
在遇到**await**关键字之后，系统做了以下工作：

1.  异步方法将被挂起
2.  将控制权返回给调用者
3.  使用线程池中的线程（而非额外创建新的线程）来计算await表达式的结果，所以await不会造成程序的阻塞
4.  完成对await表达式的计算之后，若await表达式后面还有代码则由执行await表达式的线程（不是  调用方所在的线程）继续执行这些代码



#### Tips

- 要用按位与的操作来判断线程是否被阻塞

  `bool blocked=(someThread.ThreadState & ThreadState.WaitSleepJoin)!=0`

- 如果前台线程结束。后台线程的finally块不会被执行使用`Join()`方法解决或者`single construct`

#### 提升线程优先级

- 提升线程优先级的时候需要特别注意他可能"饿死"其他线程

- 如果想让某线程（__Thread__）的优先级比其他进程（__Process__）中的线程（__Thread__）高，那必须提升进程（__Process__）的优先级

- 使用 __System.Diagnostics__下的 __Process__类  

    `using Process p= Process.GetCurrrentProcess();`

  ​              `p.PriorityClasss=PriorityClasss.High;`

  

- 这可以很好地用于只做少量工作且需要较低延迟的非UI进程。

- 对于需求大量计算的应用程序（尤其是有UI的应用程序），t提高进程优先级可能会使其他进程饿死，从而降级整个计算机的速度。

  

  


